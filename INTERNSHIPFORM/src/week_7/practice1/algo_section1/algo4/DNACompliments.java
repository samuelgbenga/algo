package week_7.practice1.algo_section1.algo4;

//Background
//        Deoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the
//        "instructions" for the development and functioning of living organisms.
//
//        If you want to know more http://en.wikipedia.org/wiki/DNA
//
//        DNA is created by two strands of nucleotides that are bonded together in complementary pairs.
//        For each base on one side, there is an opposite base on the other side.
//        There are 4 symbols used to represent the bases, A, T, C, and G.
//
//        Symbols A and T are complements of each other, as are C and G.
//
//        Task
//        You have function with one side of the DNA, you need to get the other complementary side.
//        The DNA strand may be empty if there is no DNA at all. In this case, you can simple return the empty string.
//
//        Specification
//        Challenge.dnaComplement(dna)
//        Parameters
//        dna: String - DNA strand
//
//        Return Value
//        String - A new string generated by returning the complement of the input strand.
//
//        Constraints
//        It will always be a string, but it might be empty.
//
//        It will never be null/nil or undefined.
//
//        Examples
//        dna	Return Value
//        "A"	"T"
//        "T"	"A"
//        "C"	"G"
//        "G"	"C"
//        "ATTGC"	"TAACG"
//        ""	""


// Test case
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

@DisplayName("dnaComplement")
 class DnaComplementTest {
    @Nested
    @DisplayName("basic tests")
    class BasicTests {

        @Test
        @DisplayName("should work for a single A")
        public void shouldWorkForASingleA() {
            assertEquals("T", DNACompliments.dnaComplement("A"));
        }

        @Test
        @DisplayName("should work for a single T")
        public void shouldWorkForASingleT() {
            assertEquals("A", DNACompliments.dnaComplement("T"));
        }

        @Test
        @DisplayName("should work for a single C")
        public void shouldWorkForASingleC() {
            assertEquals("G", DNACompliments.dnaComplement("C"));
        }

        @Test
        @DisplayName("should work for a single G")
        public void shouldWorkForASingleG() {
            assertEquals("C", DNACompliments.dnaComplement("G"));
        }

        @Test
        @DisplayName("should work for a ATTGC")
        public void shouldWorkForAAttgc() {
            assertEquals("TAACG", DNACompliments.dnaComplement("ATTGC"));
        }

        @Test
        @DisplayName("should work for a GTACAT")
        public void shouldWorkForAGtacat() {
            assertEquals("CATGTA", DNACompliments.dnaComplement("GTACAT"));
        }

        @Test
        @DisplayName("should work for a CGCG")
        public void shouldWorkForACgcg() {
            assertEquals("GCGC", DNACompliments.dnaComplement("CGCG"));
        }

        @Test
        @DisplayName("should work for a very long input")
        public void shouldWorkForAVeryLongInput() {
            assertEquals("CATAGCTAGCTAGCTAGCTAATATAAAAGCTGCTCTAAATTTATATATATATATGCTCTCTTATGTCTATCTGTCTAAT", DNACompliments.dnaComplement("GTATCGATCGATCGATCGATTATATTTTCGACGAGATTTAAATATATATATATACGAGAGAATACAGATAGACAGATTA"));
        }
    }
}


public class DNACompliments {
    public static void main(String[] args) {
        // test your cases here
        System.out.println(dnaComplement("ATTGC"));


    }

    public static String dnaComplement(String dna) {
        // do your magic here
       if(dna.length() == 0) return "";

        String pair = "";

       for(int i = 0; i< dna.length(); i++){
           String str = String.valueOf(dna.charAt(i));
           switch(str){
               case "A": pair += "T"; break;
               case "T": pair += "A"; break;
               case "C": pair += "G"; break;
               case "G": pair += "C"; break;
           }
       }

       return pair;
    }
}